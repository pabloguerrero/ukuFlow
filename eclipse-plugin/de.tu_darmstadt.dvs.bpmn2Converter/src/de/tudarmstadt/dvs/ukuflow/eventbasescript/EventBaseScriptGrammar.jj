/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options
{
  LOOKAHEAD= 2;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;

  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = true;
  IGNORE_CASE = true;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = true;
}PARSER_BEGIN(EventBaseScript)package de.tudarmstadt.dvs.ukuflow.eventbasescript;
import java.io.FileNotFoundException;
import java.io.FileInputStream;
public class EventBaseScript{
  public static void main(String args[]) throws ParseException
  {
    String fileName = "eventbasescript.txt";
    EventBaseScript INSTANCE = null;
    try
    {
      INSTANCE = new EventBaseScript(new FileInputStream(fileName));
    }
    catch (FileNotFoundException e1)
    {
      e1.printStackTrace();
    }
    System.out.println("testbegin");
    INSTANCE.validate();
    System.out.println("testdone");
  }}PARSER_END(EventBaseScript)SKIP :{
  " "| "\r"| "\t"| "\n"}TOKEN : /* binary logical operators */
{
  < AND :
    (
      "AND"
    | "&"
    | "&&"
    ) >
| < OR :
    (
      "OR"
    | "|"
    | "||"
    ) >
| < NOT :
    (
      "NOT"
    | "~"
    ) >
}
TOKEN:{   < COMPOSITION_POLICY :("CP1"|"CP2")> 
|  < EVICTION : ("EV1"|"EV2")>
}
//< EVENT_OUTPUT_TYPE > <COMPARISON > <EVENT_OUTPUT_VALUE >
TOKEN :
{
  < EVENT_OUTPUT_TYPE:
  ("TYPE"|"NODE"|"SENSOR"|"MAGNITUDE"|"TIME"|"SCOPE") >}
TOKEN:
{
  < COMPARISON :
  ("<"|">"|"<="|">="|"==") >}


TOKEN : /* BOOLEAN */
{
  < BOOLEAN :
    (
      < TRUE >
    | < FALSE >
    ) >
| < #TRUE :
    (
      "TRUE"
    | "true"
    ) >
| < #FALSE :
    (
      "FALSE"
    | "false"
    ) >
}

TOKEN :/** KEYWORD*/
{
  < PEG : "PERIODIC_EG" >
| < APEG : "PATTERNED_EG" >
| < ADEG : "DISTRIBUTION_EG" >
| < SEF : "SIMPLE_EF" >
| < CEF : "COMPLEX_EF" >
| < TOP : "TOP" >
}
TOKEN : /* SENSOR TYPE */
{
  <SENSOR_TYPE:(
  "SENSOR_LIGHT_PAR_RAW" 
|   "SENSOR_LIGHT_TSR_RAW"
|   "SENSOR_TEMPERATURE_RAW"
|   "SENSOR_TEMPERATURE_CELSIUS"
|   "SENSOR_TEMPERATURE_FAHRENHEIT"
|   "SENSOR_HUMIDITY_RAW"
|   "SENSOR_HUMIDITY_PERCENT"
|   "SENSOR_ACCM_X_AXIS"
|   "SENSOR_ACCM_Y_AXIS" 
|   "SENSOR_ACCM_Z_AXIS"
|   "SENSOR_VOLTAGE_RAW"
|   "SENSOR_CO2"
|   "SENSOR_CO"
|   "NODE_ID" ) >
}
TOKEN:
{
  < BINARY : (["0","1"])+ >
}
TOKEN : /* Numeric CONSTANTS */
{
    < NUMBER: (["-","+"])? ( ["0"-"9"] )+ >
}
/*
TOKEN :
{
  < PERIODIC:"PERIODIC_EG" >
| < PATTERNED:"PATTERNED_EG" >
| < DISTRIBUTION:"DISTRIBUTION_EG" >
}
*/
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER :
    (
      < LETTER >
    | "_"
    )
    (
      < LETTER >
    | < DIGIT >
    | "_"
    )* >
| < #LETTER : [ "\u0024", "\u0041"-"\u005a", "\u005f", "\u0061"-"\u007a", "\u00c0"-"\u00d6", "\u00d8"-"\u00f6", "\u00f8"-"\u00ff", "\u0100"-"\u1fff", "\u3040"-"\u318f", "\u3300"-"\u337f", "\u3400"-"\u3d2d", "\u4e00"-"\u9fff", "\uf900"-"\ufaff" ] >
| < #DIGIT : [ "\u0030"-"\u0039", "\u0660"-"\u0669", "\u06f0"-"\u06f9", "\u0966"-"\u096f", "\u09e6"-"\u09ef", "\u0a66"-"\u0a6f", "\u0ae6"-"\u0aef", "\u0b66"-"\u0b6f", "\u0be7"-"\u0bef", "\u0c66"-"\u0c6f", "\u0ce6"-"\u0cef", "\u0d66"-"\u0d6f", "\u0e50"-"\u0e59", "\u0ed0"-"\u0ed9", "\u1040"-"\u1049" ] >
}

  
void validate():{
  boolean top = false;}{
(any_function())*
TOP()
(any_function())*
  < EOF >}

void any_function():{}{
 < IDENTIFIER > "="
 (
    PEG()
   |APEG()
   |ADEG()
   |SEF()
   |CEF() )
 }
void TOP():
{}
{
  < TOP > "="
  (     PEG()
 	| APEG()
 	| ADEG()
 	| SEF()
 	| CEF()
 	| < IDENTIFIER > 	
	)
  
}
/*
void assigment_PEG():{}{
  
  < IDENTIFIER > "=" PEG()}
void assigment_APEG():{}{  < IDENTIFIER > "=" APEG()
}
void assigment_ADEG():{}{  < IDENTIFIER >"=" ADEG()
}
void assigment_SEF():
{}{  < IDENTIFIER > "=" SEF()
}
void assigment_CEF():
{}{  < IDENTIFIER > "=" CEF()
}
*/
void PEG(): /* PERIODIC */
{}
{
  < PEG > <SENSOR_TYPE > "^" Number() "@s" < IDENTIFIER >
  
}
void APEG(): /* APERIODIC PATTERNED*/
{}
{
  <APEG > <SENSOR_TYPE > "^" < BINARY > Number() "@s" < IDENTIFIER >
}
void ADEG(): /*APERIODIC DISTRIBUTED */
{}
{
  < ADEG > <SENSOR_TYPE > "^" < IDENTIFIER > (Number())* "@s" <IDENTIFIER >
}
void SEF(): /* SIMPLE EVENT FILTER*/
{}
{
  < SEF >
  "{"
  Constraint()
  ("," Constraint())*
  "}"
  "{"  (   < IDENTIFIER > 
  | PEG()
  | APEG()
  | ADEG()
  )+
  "}"   
}
void Constraint():
{}
{
  < EVENT_OUTPUT_TYPE > <COMPARISON >
  (
    < IDENTIFIER >
  | Number()
  | < SENSOR_TYPE >
  )
}
void CEF(): /* COMPLEX EVENT FILTER */
{}
{
  < CEF > AND_operator()// (policy())?
}

void policy():{}{
  "/"< COMPOSITION_POLICY > "/"< EVICTION >}
void AND_operator():
{}
{
  OR_operator()
  (
  < AND >
  OR_operator()
  )?
}
void OR_operator():
{}
{
  NOT_operator()
  (    < OR >
    NOT_operator()
  )?
}

void NOT_operator():
{}
{
  Terminate_Operand()
| < NOT > "("AND_operator() ")"
| "("AND_operator() ")"
}
void Terminate_Operand():
{}
{
  < IDENTIFIER >
| PEG()
| APEG()
| ADEG()
| SEF()
| CEF()
}
void Number():
{}
{
  < BINARY >
| < NUMBER >
}